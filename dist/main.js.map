{"version":3,"sources":["webpack://tower_game/./node_modules/cooljs/engine.js","webpack://tower_game/./node_modules/cooljs/index.js","webpack://tower_game/./node_modules/cooljs/instance.js","webpack://tower_game/./node_modules/cooljs/tween.js","webpack://tower_game/./node_modules/cooljs/utils.js","webpack://tower_game/./src/animateFuncs.js","webpack://tower_game/./src/background.js","webpack://tower_game/./src/block.js","webpack://tower_game/./src/cloud.js","webpack://tower_game/./src/constant.js","webpack://tower_game/./src/flight.js","webpack://tower_game/./src/hook.js","webpack://tower_game/./src/line.js","webpack://tower_game/./src/tutorial.js","webpack://tower_game/./src/utils.js","webpack://tower_game/webpack/bootstrap","webpack://tower_game/webpack/runtime/define property getters","webpack://tower_game/webpack/runtime/hasOwnProperty shorthand","webpack://tower_game/webpack/runtime/make namespace object","webpack://tower_game/./src/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAgC;AACL;;AAE3B,OAAO,uDAAuD,GAAG,mCAAK;;AAEvD;AACf,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mCAAmC,YAAY;AAC/C,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mCAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,uBAAuB,8BAA8B;AACrD,8BAA8B,mBAAmB;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,kDAAkD;AAClD,WAAW,gBAAgB;AAC3B,uBAAuB,2CAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;AC1jB4C;AACI;;;;;;;;;;;;;;;ACDjC;AACf,yBAAyB;AACzB,WAAW,iCAAiC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;;;;;;;ACjBd;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,CAAC;;AAEM;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AChCiC;AACkB;AAMnC;AACoB;AACE;;AAE/B;AACP,0CAA0C,mDAAqB;AAC/D;AACA,0CAA0C,mDAAqB;AAC/D,yCAAyC,kDAAoB;AAC7D,uCAAuC,gDAAkB;AACzD;;AAEA,EAAE,yDAAgB;AAClB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE,yDAAgB;AAClB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,yDAAgB;AAClB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,SAAS,MAAM;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,0CAA0C,mDAAqB;AAC/D;AACA,gDAAgD,mBAAmB,iDAAmB,EAAE;AACxF,qBAAqB,2CAAa,EAAE,0CAAY;AAChD,QAAQ,qDAAa,YAAY,wDAAgB;AACjD,iCAAiC,qDAAuB;AACxD,sBAAsB,oDAAY;AAClC;AACA;AACA;AACA;AACA,uBAAuB,iDAAmB,qBAAqB,iDAAmB;AAClF,uBAAuB,mDAAqB;AAC5C,2BAA2B,uDAAyB;AACpD,sBAAsB,4CAAQ;AAC9B,qBAAqB,mBAAmB,iDAAmB,EAAE;AAC7D,cAAc,+CAAW;AACzB,eAAe,gDAAY;AAC3B,KAAK;AACL;AACA;AACA,iDAAiD,mDAAqB;AACtE;AACA;AACA,MAAM,mDAAS;AACf;AACA;AACA,MAAM,mDAAS;AACf;AACA;AACA,MAAM,mDAAS;AACf;AACA;AACA,MAAM,mDAAS;AACf;AACA;AACA,MAAM,mDAAS;AACf;AACA;AACA,MAAM,mDAAS;AACf;AACA;AACA,MAAM,mDAAS;AACf;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC1HyD;AACnB;;AAE/B;AACP;AACA;AACA;AACA;AACA,wCAAwC,kDAAoB;AAC5D;AACA;AACA;AACA;AACA,IAAI,uDAAyB;AAC7B,oCAAoC,wDAAgB,UAAU,6BAA6B;AAC3F;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI,qDAAuB;AAC3B;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAoB;AACzC,qBAAqB,wDAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe,IAAI,eAAe,IAAI,eAAe;AACrE;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,6DAA+B;AACzE,MAAM,qDAAa;AACnB;AACA,MAAM,6DAA+B;AACrC,wBAAwB,wDAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wDAA0B,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;AC1FgB;AACsB;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAmB;AAC3D,0BAA0B,4CAAc;AACxC;AACA,0CAA0C,mDAAqB;AAC/D;AACA,IAAI,6DAAqB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,iDAAmB;AAC7C;AACA;AACA;AACA,wBAAwB,0CAAY;AACpC,MAAM,uDAAc;AACpB;AACA,GAAG;AACH;AACA,sBAAsB,0CAAY;AAClC,IAAI,uDAAc;AAClB;AACA;;AAEO;AACP;AACA,wCAAwC,iDAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA,eAAe,4CAAc;AAC7B,4CAA4C,iDAAmB;AAC/D,6CAA6C,kDAAoB;AACjE;AACA;AACA;AACA;AACA;AACA,SAAS,4CAAc;AACvB;AACA,QAAQ,uDAAyB;AACjC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,iDAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA,iBAAiB,2CAAa;AAC9B;AACA,SAAS,2CAAa;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iDAAmB;AACxC;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2CAAa;AAClC,sDAAsD,mDAAqB;AAC3E,UAAU,wDAAe;AACzB,iCAAiC,uDAAyB;AAC1D;AACA,mCAAmC,wDAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAiB;AAChD;AACA;AACA;AACA,YAAY,iDAAQ;AACpB;AACA,WAAW;AACX,YAAY,gDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,2CAAa;AACtB;AACA,QAAQ,uDAAyB;AACjC,oCAAoC,wDAAgB,UAAU,6BAA6B;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,4DAAoB;AACxC;AACA,SAAS,iDAAmB;AAC5B,SAAS,kDAAoB;AAC7B,mCAAmC,kDAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,UAAU;AACnB;AACA;AACA;;AAEA;AACA,SAAS,MAAM;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,SAAS,SAAS;AAClB;AACA,SAAS,4CAAc;AACvB;AACA;AACA,SAAS,2CAAa;AACtB,SAAS,2CAAa;AACtB;AACA;AACA,SAAS,iDAAmB;AAC5B,SAAS,kDAAoB;AAC7B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzPyD;AACnB;;AAEtC;AACA,SAAS,QAAQ;AACjB;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,wCAAwC,gDAAkB;AAC1D,yCAAyC,gDAAkB;AAC3D;AACA;AACA;AACA,OAAO,uCAAuC;AAC9C,OAAO,wCAAwC;AAC/C,OAAO,yBAAyB;AAChC,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,qDAAa;AACnB,kBAAkB,wDAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,SAAS,MAAM;AACf;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnDO;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzC0B;AACK;;AAEtC;AACA;AACA;AACA,GAAG;AACH,SAAS,SAAS;AAClB,kCAAkC,gDAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGO;AACP,SAAS,uBAAuB;AAChC;AACA,kCAAkC,gDAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,SAAS,MAAM;AACf;AACA;AACA;;AAEO;AACP,yCAAyC,kDAAoB;AAC7D;AACA,qBAAqB,4CAAQ;AAC7B,oBAAoB,OAAO;AAC3B;AACA;AACA,GAAG;AACH,uBAAuB,OAAO;AAC9B;AACA,6BAA6B,kDAAoB;AACjD,qBAAqB,kDAAoB;AACzC;;;;;;;;;;;;;;;;;;ACjF+C;AACT;;AAE/B;AACP,wCAAwC,iDAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,qDAAuB;AAC3B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,uDAAyB;AAC7B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,0CAA0C,mDAAqB;AAC/D;AACA,IAAI,6DAAqB;AACzB;AACA;AACA;AACA;AACA;;AAEO;AACP,SAAS,MAAM;AACf,wCAAwC,iDAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpDgE;AAC1B;;AAE/B;AACP;AACA;AACA,6BAA6B,wDAA0B;AACvD;AACA,qDAAqD,iDAAmB;AACxE;AACA;AACA,IAAI,uDAAyB;AAC7B,gCAAgC,wDAAgB,UAAU,6BAA6B;AACvF;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,4BAA4B,4DAAoB;AAChD;AACA;AACA;;AAEO;AACP,SAAS,aAAa;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtCuC;AACD;;AAE/B;AACP,SAAS,gBAAgB;AACzB,SAAS,OAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,+BAA+B,uDAAyB;AACxD;AACA;AACA,MAAM,qDAAa,aAAa,iDAAmB;AACnD;AACA;AACA,SAAS,MAAM;AACf,SAAS,OAAO;AAChB;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjCsC;;AAE/B;AACP,4BAA4B,uDAAyB;;AAE9C;AACP;AACA,0CAA0C,mDAAqB;AAC/D,uCAAuC,kDAAoB;AAC3D;AACA;AACA;AACA;AACA;;AAEO;AACP,0CAA0C,mDAAqB;AAC/D,uCAAuC,gDAA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","file":"main.js","sourcesContent":["import * as utils from './utils'\nimport Tween from './tween'\n\nconst { requestAnimationFrameTool, isFunction, isTouchDevice } = utils\n\nexport default class Engine {\n  constructor(option = {}) {\n    if (!document.createElement('canvas').getContext) {\n      window.alert('HTML5 Canvas is not supported in your browser.') // eslint-disable-line\n      return\n    }\n    const {\n      canvasId, debug, width, height, highResolution, loadLimit, soundOn\n    } = option\n    let canvasWidth = width || window.innerWidth\n    let canvasHeight = height || window.innerHeight\n    this.canvas = document.getElementById(canvasId)\n    if (highResolution) {\n      this.canvas.style.width = `${canvasWidth}px`\n      this.canvas.style.height = `${canvasHeight}px`\n      canvasWidth *= 2\n      canvasHeight *= 2\n    }\n    this.highResolution = highResolution\n    this.canvas.width = canvasWidth\n    this.canvas.height = canvasHeight\n    this.width = this.canvas.width\n    this.height = this.canvas.height\n    this.calWidth = this.width * 0.5\n    this.calHeight = this.height * 0.5\n    // general\n    this.debug = !!debug\n    this.ctx = this.canvas.getContext('2d')\n    this.defaultLayer = 'default'\n    this.layerArr = [this.defaultLayer]\n    this.instancesObj = {}\n    this.instancesObj[this.defaultLayer] = []\n    this.instancesReactionArr = []\n    this.utils = utils\n    this.customVariable = {}\n    const self = this\n    this.isTouchDevice = isTouchDevice()\n    this.debugArr = []\n    // assets\n    this.assetsObj = {\n      image: {},\n      audio: {}\n    }\n    this.assetsCount = {\n      image: 0,\n      audio: 0\n    }\n    this.assetsErrorQueue = []\n    this.assetsErrorCount = 0\n    this.loadLimit = loadLimit || 3\n    // audio\n    this.soundOn = !!soundOn\n    // time\n    this.fps = 0\n    this.lastTime = 0\n    this.lastPausedAt = 0\n    this.pausedTime = 0\n    this.paused = false\n    this.timeMovement = {}\n    this.timeMovementStartArr = []\n    this.timeMovementFinishArr = []\n    // keys\n    this.keyUpListeners = {}\n    this.keyDownListeners = {}\n    this.keyPressListeners = {}\n    // hooks\n    this.startAnimate = () => {\n    }\n    this.paintUnderInstance = () => {\n    }\n    this.paintAboveInstance = () => {\n    }\n    this.endAnimate = () => {\n    }\n    this.touchStartListener = () => {\n    }\n    this.touchEndListener = () => {\n    }\n    this.touchMoveListener = () => {\n    }\n    // global event listener\n    // key\n    document.addEventListener('keyup', (e) => {\n      self.keyListener(e, 'keyup')\n    }, false)\n    document.addEventListener('keydown', (e) => {\n      self.keyListener(e, 'keydown')\n    }, false)\n    document.addEventListener('keypress', (e) => {\n      self.keyListener(e, 'keypress')\n    }, false)\n    // touch\n    if (this.isTouchDevice) {\n      document.addEventListener('touchstart', (e) => {\n        self.touchStartListener(e)\n      }, false)\n      document.addEventListener('touchend', (e) => {\n        self.touchEndListener(e)\n      }, false)\n      document.addEventListener('touchmove', (e) => {\n        self.touchMoveListener(e)\n      }, false)\n    } else {\n      document.addEventListener('mousedown', (e) => {\n        self.touchStartListener(e)\n      }, false)\n      document.addEventListener('mouseup', (e) => {\n        self.touchEndListener(e)\n      }, false)\n      document.addEventListener('mousemove', (e) => {\n        self.touchMoveListener(e)\n      }, false)\n    }\n  }\n\n  triggerReaction(x, y) {\n    let calX = x\n    let calY = y\n    if (this.highResolution) {\n      calX *= 2\n      calY *= 2\n    }\n    this.instancesReactionArr.forEach((i) => {\n      if (!i.visible) return\n      if (calX >= i.x && calX<= i.x + i.width && calY >= i.y && calY<= i.y + i.height) {\n        i.trigger(i, this)\n      }\n    })\n  }\n\n  addAudio(name, src, retry = 0) {\n    if (!this.soundOn) return\n    if (!retry) this.assetsCount.audio += 1\n    const a = new window.Audio()\n    a.src = src\n    // a.addEventListener('canplaythrough', () => {\n    //   this.assetsObj.audio[name] = a\n    // }, false)\n    // bug sometime not trigger canplaythrough\n    this.assetsObj.audio[name] = a\n    a.addEventListener('error', () => {\n      this.assetsErrorQueue.push({\n        name,\n        src,\n        retry: retry + 1,\n        type: 'audio'\n      })\n    }, false)\n    a.load()\n  }\n\n  getAudio(name) {\n    return this.assetsObj.audio[name]\n  }\n\n  playAudio(name, loop = false) {\n    if (!this.soundOn) return\n    const audio = this.getAudio(name)\n    // const audio = document.getElementById(name)\n    if (audio) {\n      audio.play()\n      if (!loop) return\n      audio.addEventListener('ended', () => {\n        audio.currentTime = 0\n        audio.play()\n      }, false)\n    }\n  }\n\n  pauseAudio(name) {\n    const audio = this.getAudio(name)\n    if (audio) {\n      audio.pause()\n    }\n  }\n\n  setVariable(key, value) {\n    this.customVariable[key] = value\n  }\n\n  getVariable(key, defaultValue = null) {\n    const customVariable = this.customVariable[key]\n    if (customVariable) {\n      return customVariable\n    }\n    if (defaultValue !== null) {\n      this.setVariable(key, defaultValue)\n      return defaultValue\n    }\n    return null\n  }\n\n  addImg(name, src, retry = 0) {\n    if (!retry) this.assetsCount.image += 1\n    const i = new window.Image()\n    i.src = src\n    i.onload = () => {\n      this.assetsObj.image[name] = i\n    }\n    i.onerror = () => {\n      this.assetsErrorQueue.push({\n        name,\n        src,\n        retry: retry + 1,\n        type: 'image'\n      })\n    }\n  }\n\n  getImg(name) {\n    return this.assetsObj.image[name]\n  }\n\n  animate(time) {\n    const gameTime = time - this.pausedTime\n    const self = this\n    if (this.paused) {\n      setTimeout(() => {\n        this.animate.call(self, gameTime)\n      }, 100)\n      return\n    }\n    this.tick(gameTime)\n    this.clean()\n    this.startAnimate(this, gameTime)\n    this.paintUnderInstance(this)\n    this.updateInstances(gameTime)\n    this.paintInstances()\n    this.paintAboveInstance()\n    this.endAnimate(this, gameTime)\n    this.tickTimeMovement()\n    this.debug && this.showFps()\n    this.debug && this.drawDebug()\n    requestAnimationFrameTool((_time) => {\n      this.animate.call(self, _time)\n    })\n  }\n\n  showFps() {\n    this.ctx.save()\n    this.ctx.fillStyle = 'red'\n    this.ctx.font = `${this.highResolution ? 32 : 16}px Arial`\n    this.ctx.fillText(`FPS: ${this.fps.toFixed()}`, 5, this.highResolution ? 40 : 20)\n    this.ctx.restore()\n  }\n\n  debugLineX(y) {\n    this.debugArr.push({\n      type: 'lineX',\n      y\n    })\n  }\n\n  debugLineY(x) {\n    this.debugArr.push({\n      type: 'lineY',\n      x\n    })\n  }\n\n  debugDot(x, y) {\n    this.debugArr.push({\n      type: 'dot',\n      x,\n      y\n    })\n  }\n\n  drawDebug() {\n    this.debugArr.forEach((i) => {\n      const { type, x, y } = i\n      switch (type) {\n        case 'dot':\n          this.drawDebugDot(x, y)\n          break\n        case 'lineX':\n          this.drawDebugLine(null, y)\n          break\n        case 'lineY':\n          this.drawDebugLine(x, null)\n          break\n        default:\n          break\n      }\n    })\n    this.instancesReactionArr.forEach((i) => {\n      if (!i.visible) return\n      this.ctx.strokeStyle = 'red'\n      this.ctx.beginPath()\n      this.ctx.rect(i.x, i.y, i.width, i.height)\n      this.ctx.stroke()\n    })\n  }\n\n  drawDebugLine(x, y) {\n    let from = [0, y]\n    let to = [this.width, y]\n    if (x) {\n      from = [x, 0]\n      to = [x, this.height]\n    }\n    this.ctx.save()\n    this.ctx.strokeStyle = 'red'\n    this.ctx.beginPath()\n    this.ctx.moveTo(...from)\n    this.ctx.lineTo(...to)\n    this.ctx.stroke()\n    this.ctx.restore()\n  }\n\n  drawDebugDot(x, y) {\n    this.ctx.save()\n    this.ctx.fillStyle = 'red'\n    this.ctx.beginPath()\n    this.ctx.arc(x, y, 2, 0, 2 * Math.PI, true)\n    this.ctx.fill()\n    this.ctx.fillStyle = 'white'\n    this.ctx.beginPath()\n    this.ctx.arc(x, y, 1, 0, 2 * Math.PI, true)\n    this.ctx.fill()\n    this.ctx.restore()\n  }\n\n  tick(time) {\n    this.updateFps(time)\n    this.lastTime = time\n  }\n\n  updateFps(time) {\n    if (this.lastTime === 0) {\n      this.fps = 60\n    } else {\n      this.fps = 1000 / (time - this.lastTime)\n    }\n  }\n\n  pixelsPerFrame(velocity) {\n    return velocity / this.fps\n  }\n\n  tickTimeMovement() {\n    this.timeMovementStartArr.forEach((name) => {\n      this.timeMovement[name].processing = true\n    })\n    this.timeMovementStartArr = []\n    this.timeMovementFinishArr.forEach((name) => {\n      delete this.timeMovement[name]\n    })\n    this.timeMovementFinishArr = []\n  }\n\n  getTimeMovement(name, value, render, option = {}) {\n    const { before, after } = option\n    const timingFunc = Tween[option.easing || 'linear']\n    const movementInstanceName = option.name || 'default'\n    const movement = this.timeMovement[name]\n    if (!movement) {\n      return\n    }\n    if (!movement.processing) {\n      this.timeMovementStartArr.push(name)\n      movement.store[movementInstanceName] = []\n      value.forEach((v) => {\n        movement.store[movementInstanceName].push({\n          start: parseFloat(v[0]),\n          end: parseFloat(v[1])\n        })\n      })\n      before && before()\n    }\n    const processRender = (lastRender = false) => {\n      const { duration } = movement\n      let t = duration\n      if (!lastRender) {\n        const currentTime = this.utils.getCurrentTime()\n        const { startTime } = movement\n        t = currentTime - startTime\n      }\n      const values = movement.store[movementInstanceName]\n        .map(v => timingFunc(t, v.start, v.end - v.start, duration))\n      render.apply(this, values)\n    }\n    if (this.checkTimeMovement(name)) {\n      processRender()\n    } else {\n      this.timeMovementFinishArr.push(name)\n      processRender(true)\n      after && after()\n    }\n  }\n\n  checkTimeMovement(name) {\n    const movement = this.timeMovement[name] || {}\n    return this.utils.getCurrentTime() <= movement.endTime\n  }\n\n  setTimeMovement(name, duration) {\n    const currentTime = this.utils.getCurrentTime()\n    this.timeMovement[name] = {\n      startTime: currentTime,\n      endTime: currentTime + duration,\n      duration,\n      store: {}\n    }\n  }\n\n  clean() {\n    this.ctx.clearRect(0, 0, this.width, this.height)\n    this.debugArr = []\n  }\n\n  addLayer(layer) {\n    this.layerArr.push(layer)\n    this.instancesObj[layer] = []\n  }\n\n  removeLayer(layer) {\n    this.layerArr = this.layerArr.filter(i => i !== layer)\n    delete this.instancesObj[layer]\n  }\n\n  swapLayer(index1, index2) {\n    this.utils.arraySwap(this.layerArr, index1, index2)\n  }\n\n  addInstance(instance, layer = this.defaultLayer) {\n    this.instancesObj[layer].push(instance)\n    if (instance.trigger) this.instancesReactionArr.push(instance)\n  }\n\n  getInstance(name, layer = this.defaultLayer) {\n    return this.instancesObj[layer].filter(i => i.name === name)[0]\n  }\n\n  removeInstance(name, layer = this.defaultLayer) {\n    const instance = this.getInstance(name, layer)\n    if (instance) {\n      this.instancesObj[layer] = this.instancesObj[layer].filter(i => i.name !== name)\n      if (instance.trigger) {\n        this.instancesReactionArr = this.instancesReactionArr.filter(i => i.name !== name)\n      }\n    }\n  }\n\n  updateInstances(time) {\n    this.layerArr.forEach((l) => {\n      this.instancesObj[l].forEach((i) => {\n        i.update && i.update(this, time)\n      })\n    })\n  }\n\n  paintInstances() {\n    this.layerArr.forEach((l) => {\n      this.instancesObj[l].forEach((i) => {\n        i.paint && i.paint(this)\n      })\n    })\n  }\n\n  togglePaused() {\n    const now = this.utils.getCurrentTime()\n    this.paused = !this.paused\n    if (this.paused) {\n      this.lastPausedAt = now\n    } else {\n      this.pausedTime += (now - this.lastPausedAt)\n    }\n  }\n\n  addKeyUpListener(key, listener) {\n    this.keyUpListeners[key] = listener\n  }\n\n  addKeyDownListener(key, listener) {\n    this.keyDownListeners[key] = listener\n  }\n\n  addKeyPressListener(key, listener) {\n    this.keyPressListeners[key] = listener\n  }\n\n  findKeyListener(key, type) {\n    if (type === 'keyup') {\n      return this.keyUpListeners[key]\n    } else if (type === 'keydown') {\n      return this.keyDownListeners[key]\n    }\n    return this.keyPressListeners[key]\n  }\n\n  keyListener(e, type) {\n    let key\n    switch (e.keyCode) {\n      case 13:\n        key = 'enter'\n        break\n      case 32:\n        key = 'space'\n        break\n      case 37:\n        key = 'leftArrow'\n        break\n      case 39:\n        key = 'rightArrow'\n        break\n      case 38:\n        key = 'upArrow'\n        break\n      case 40:\n        key = 'downArrow'\n        break\n      default:\n        key = e.keyCode\n        break\n    }\n    const listener = this.findKeyListener(key, type)\n    if (listener) listener()\n  }\n\n\n  load(onload, loading) {\n    const id = setInterval(() => {\n      const assetsTotalCount = this.assetsCount.image + this.assetsCount.audio\n      const assetsLoadedCount = Object.keys(this.assetsObj.image).length\n        + Object.keys(this.assetsObj.audio).length\n      if (loading && isFunction(loading)) {\n        loading({\n          success: assetsLoadedCount,\n          failed: this.assetsErrorCount,\n          total: assetsTotalCount\n        })\n      }\n      if (this.assetsErrorQueue.length > 0) {\n        this.assetsErrorQueue.forEach((i) => {\n          const {\n            retry, name, src, type\n          } = i\n          if (retry >= this.loadLimit) {\n            this.assetsErrorCount += 1\n          } else if (type === 'image') {\n            this.addImg(name, src, retry)\n          } else {\n            this.addAudio(name, src, retry)\n          }\n        })\n        this.assetsErrorQueue = []\n      }\n      if (assetsLoadedCount === assetsTotalCount) {\n        if (onload && isFunction(onload)) {\n          onload()\n        } else {\n          this.init()\n        }\n        clearInterval(id)\n      }\n    }, 200)\n  }\n\n  init() {\n    const self = this\n    requestAnimationFrameTool((time) => {\n      this.animate.call(self, time)\n    })\n  }\n}\n","export { default as Engine } from './engine'\nexport { default as Instance } from './instance'\n","export default class Instance {\n  constructor(option = {}) {\n    const { name, painter, action, trigger } = option\n    this.name = name\n    this.x = 0\n    this.y = 0\n    this.width = 0\n    this.height = 0\n    this.ax = 0\n    this.ay = 0\n    this.vx = 0\n    this.vy = 0\n    this.visible = true\n    this.painter = painter || null\n    this.action = action || null\n    this.trigger = trigger || null\n    this.ready = false\n  }\n\n  paint(engine) {\n    if (this.painter !== null && this.visible) {\n      this.painter(this, engine)\n    }\n  }\n\n  update(engine, time) {\n    if (this.action !== null) {\n      this.action(this, engine, time)\n    }\n  }\n\n  updateWidth(width) {\n    this.width = width\n    this.calWidth = width / 2\n  }\n\n  updateHeight(height) {\n    this.height = height\n    this.calHeight = height / 2\n  }\n}\n","/* eslint-disable */\nconst Tween = {\n  linear: function (t, b, c, d) {\n    return c * t / d + b;\n  },\n  easeIn: function (t, b, c, d) {\n    return c * (t /= d) * t + b;\n  },\n  easeOut: function (t, b, c, d) {\n    return -c * (t /= d) * (t - 2) + b;\n  },\n  easeInOut: function (t, b, c, d) {\n    if ((t /= d / 2) < 1) return c / 2 * t * t + b;\n    return -c / 2 * ((--t) * (t - 2) - 1) + b;\n  }\n};\n\nexport default Tween;\n","export const getCurrentTime = () => (performance.now())\n\nexport const random = (min, max) => (Math.random() * (max - min)) + min\n\nexport const randomPositiveNegative = () => (Math.random() < 0.5 ? -1 : 1)\n\nexport const isFunction = f => (typeof f === 'function')\n\nexport const isTouchDevice = () => ('ontouchstart' in window || window.navigator.msMaxTouchPoints)\n\nexport const requestAnimationFrameTool = ((() => {\n  const FPS = 60\n  let timeout = 1000 / FPS\n  return window.requestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    window.oRequestAnimationFrame ||\n    window.msRequestAnimationFrame ||\n    ((callBack) => {\n      window.setTimeout(() => {\n        const start = getCurrentTime()\n        callBack(start)\n        const end = getCurrentTime()\n        timeout = (1000 / FPS) - (end - start)\n      }, timeout)\n    })\n}))()\n\nexport const arraySwap = (array, index1, index2) => {\n  const temp = array[index2]\n  array[index2] = array[index1]\n  array[index1] = temp\n}\n","import { Instance } from 'cooljs'\nimport { blockAction, blockPainter } from './block'\nimport {\n  checkMoveDown,\n  getMoveDownValue,\n  drawYellowString,\n  getAngleBase\n} from './utils'\nimport { addFlight } from './flight'\nimport * as constant from './constant'\n\nexport const endAnimate = (engine) => {\n  const gameStartNow = engine.getVariable(constant.gameStartNow)\n  if (!gameStartNow) return\n  const successCount = engine.getVariable(constant.successCount, 0)\n  const failedCount = engine.getVariable(constant.failedCount)\n  const gameScore = engine.getVariable(constant.gameScore, 0)\n  const threeFiguresOffset = Number(successCount) > 99 ? engine.width * 0.1 : 0\n\n  drawYellowString(engine, {\n    string: '层',\n    size: engine.width * 0.06,\n    x: (engine.width * 0.24) + threeFiguresOffset,\n    y: engine.width * 0.12,\n    textAlign: 'left'\n  })\n  drawYellowString(engine, {\n    string: successCount,\n    size: engine.width * 0.17,\n    x: (engine.width * 0.22) + threeFiguresOffset,\n    y: engine.width * 0.2,\n    textAlign: 'right'\n  })\n  const score = engine.getImg('score')\n  const scoreWidth = score.width\n  const scoreHeight = score.height\n  const zoomedWidth = engine.width * 0.35\n  const zoomedHeight = (scoreHeight * zoomedWidth) / scoreWidth\n  engine.ctx.drawImage(\n    score,\n    engine.width * 0.61,\n    engine.width * 0.038,\n    zoomedWidth,\n    zoomedHeight\n  )\n  drawYellowString(engine, {\n    string: gameScore,\n    size: engine.width * 0.06,\n    x: engine.width * 0.9,\n    y: engine.width * 0.11,\n    textAlign: 'right'\n  })\n  const { ctx } = engine\n  const heart = engine.getImg('heart')\n  const heartWidth = heart.width\n  const heartHeight = heart.height\n  const zoomedHeartWidth = engine.width * 0.08\n  const zoomedHeartHeight = (heartHeight * zoomedHeartWidth) / heartWidth\n  for (let i = 1; i <= 3; i += 1) {\n    ctx.save()\n    if (i <= failedCount) {\n      ctx.globalAlpha = 0.2\n    }\n    ctx.drawImage(\n      heart,\n      (engine.width * 0.66) + ((i - 1) * zoomedHeartWidth),\n      engine.width * 0.16,\n      zoomedHeartWidth,\n      zoomedHeartHeight\n    )\n    ctx.restore()\n  }\n}\n\nexport const startAnimate = (engine) => {\n  const gameStartNow = engine.getVariable(constant.gameStartNow)\n  if (!gameStartNow) return\n  const lastBlock = engine.getInstance(`block_${engine.getVariable(constant.blockCount)}`)\n  if (!lastBlock || [constant.land, constant.out].indexOf(lastBlock.status) > -1) {\n    if (checkMoveDown(engine) && getMoveDownValue(engine)) return\n    if (engine.checkTimeMovement(constant.hookUpMovement)) return\n    const angleBase = getAngleBase(engine)\n    const initialAngle = (Math.PI\n        * engine.utils.random(angleBase, angleBase + 5)\n        * engine.utils.randomPositiveNegative()\n    ) / 180\n    engine.setVariable(constant.blockCount, engine.getVariable(constant.blockCount) + 1)\n    engine.setVariable(constant.initialAngle, initialAngle)\n    engine.setTimeMovement(constant.hookDownMovement, 500)\n    const block = new Instance({\n      name: `block_${engine.getVariable(constant.blockCount)}`,\n      action: blockAction,\n      painter: blockPainter\n    })\n    engine.addInstance(block)\n  }\n  const successCount = Number(engine.getVariable(constant.successCount, 0))\n  switch (successCount) {\n    case 2:\n      addFlight(engine, 1, 'leftToRight')\n      break\n    case 6:\n      addFlight(engine, 2, 'rightToLeft')\n      break\n    case 8:\n      addFlight(engine, 3, 'leftToRight')\n      break\n    case 14:\n      addFlight(engine, 4, 'bottomToTop')\n      break\n    case 18:\n      addFlight(engine, 5, 'bottomToTop')\n      break\n    case 22:\n      addFlight(engine, 6, 'bottomToTop')\n      break\n    case 25:\n      addFlight(engine, 7, 'rightTopToLeft')\n      break\n    default:\n      break\n  }\n}\n\n","import { checkMoveDown, getMoveDownValue } from './utils'\nimport * as constant from './constant'\n\nexport const backgroundImg = (engine) => {\n  const bg = engine.getImg('background')\n  const bgWidth = bg.width\n  const bgHeight = bg.height\n  const zoomedHeight = (bgHeight * engine.width) / bgWidth\n  let offsetHeight = engine.getVariable(constant.bgImgOffset, engine.height - zoomedHeight)\n  if (offsetHeight > engine.height) {\n    return\n  }\n  engine.getTimeMovement(\n    constant.moveDownMovement,\n    [[offsetHeight, offsetHeight + (getMoveDownValue(engine, { pixelsPerFrame: s => s / 2 }))]],\n    (value) => {\n      offsetHeight = value\n    },\n    {\n      name: 'background'\n    }\n  )\n  engine.getTimeMovement(\n    constant.bgInitMovement,\n    [[offsetHeight, offsetHeight + (zoomedHeight / 4)]],\n    (value) => {\n      offsetHeight = value\n    }\n  )\n  engine.setVariable(constant.bgImgOffset, offsetHeight)\n  engine.setVariable(constant.lineInitialOffset, engine.height - (zoomedHeight * 0.394))\n  engine.ctx.drawImage(\n    bg,\n    0, offsetHeight,\n    engine.width, zoomedHeight\n  )\n}\n\nconst getLinearGradientColorRgb = (colorArr, colorIndex, proportion) => {\n  const currentIndex = colorIndex + 1 >= colorArr.length ? colorArr.length - 1 : colorIndex\n  const colorCurrent = colorArr[currentIndex]\n  const nextIndex = currentIndex + 1 >= colorArr.length - 1 ? currentIndex : currentIndex + 1\n  const colorNext = colorArr[nextIndex]\n  const calRgbValue = (index) => {\n    const current = colorCurrent[index]\n    const next = colorNext[index]\n    return Math.round(current + ((next - current) * proportion))\n  }\n  return `rgb(${calRgbValue(0)}, ${calRgbValue(1)}, ${calRgbValue(2)})`\n}\n\nexport const backgroundLinearGradient = (engine) => {\n  const grad = engine.ctx.createLinearGradient(0, 0, 0, engine.height)\n  const colorArr = [\n    [200, 255, 150],\n    [105, 230, 240],\n    [90, 190, 240],\n    [85, 100, 190],\n    [55, 20, 35],\n    [75, 25, 35],\n    [25, 0, 10]\n  ]\n  const offsetHeight = engine.getVariable(constant.bgLinearGradientOffset, 0)\n  if (checkMoveDown(engine)) {\n    engine.setVariable(\n      constant.bgLinearGradientOffset\n      , offsetHeight + (getMoveDownValue(engine) * 1.5)\n    )\n  }\n  const colorIndex = parseInt(offsetHeight / engine.height, 10)\n  const calOffsetHeight = offsetHeight % engine.height\n  const proportion = calOffsetHeight / engine.height\n  const colorBase = getLinearGradientColorRgb(colorArr, colorIndex, proportion)\n  const colorTop = getLinearGradientColorRgb(colorArr, colorIndex + 1, proportion)\n  grad.addColorStop(0, colorTop)\n  grad.addColorStop(1, colorBase)\n  engine.ctx.fillStyle = grad\n  engine.ctx.beginPath()\n  engine.ctx.rect(0, 0, engine.width, engine.height)\n  engine.ctx.fill()\n\n  // lightning\n  const lightning = () => {\n    engine.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'\n    engine.ctx.fillRect(0, 0, engine.width, engine.height)\n  }\n  engine.getTimeMovement(\n    constant.lightningMovement, [], () => {},\n    {\n      before: lightning,\n      after: lightning\n    }\n  )\n}\n\nexport const background = (engine) => {\n  backgroundLinearGradient(engine)\n  backgroundImg(engine)\n}\n\n","import {\n  getMoveDownValue,\n  getLandBlockVelocity,\n  getSwingBlockVelocity,\n  touchEventHandler,\n  addSuccessCount,\n  addFailedCount,\n  addScore\n} from './utils'\nimport * as constant from './constant'\n\nconst checkCollision = (block, line) => {\n  // 0 goon 1 drop 2 rotate left 3 rotate right 4 ok 5 perfect\n  if (block.y + block.height >= line.y) {\n    if (block.x < line.x - block.calWidth || block.x > line.collisionX + block.calWidth) {\n      return 1\n    }\n    if (block.x < line.x) {\n      return 2\n    }\n    if (block.x > line.collisionX) {\n      return 3\n    }\n    if (block.x > line.x + (block.calWidth * 0.8) && block.x < line.x + (block.calWidth * 1.2)) {\n      // -10% +10%\n      return 5\n    }\n    return 4\n  }\n  return 0\n}\nconst swing = (instance, engine, time) => {\n  const ropeHeight = engine.getVariable(constant.ropeHeight)\n  if (instance.status !== constant.swing) return\n  const i = instance\n  const initialAngle = engine.getVariable(constant.initialAngle)\n  i.angle = initialAngle *\n    getSwingBlockVelocity(engine, time)\n  i.weightX = i.x +\n    (Math.sin(i.angle) * ropeHeight)\n  i.weightY = i.y +\n    (Math.cos(i.angle) * ropeHeight)\n}\n\nconst checkBlockOut = (instance, engine) => {\n  if (instance.status === constant.rotateLeft) {\n    // 左转 要等右上角消失才算消失\n    if (instance.y - instance.width >= engine.height) {\n      instance.visible = false\n      instance.status = constant.out\n      addFailedCount(engine)\n    }\n  } else if (instance.y >= engine.height) {\n    instance.visible = false\n    instance.status = constant.out\n    addFailedCount(engine)\n  }\n}\n\nexport const blockAction = (instance, engine, time) => {\n  const i = instance\n  const ropeHeight = engine.getVariable(constant.ropeHeight)\n  if (!i.visible) {\n    return\n  }\n  if (!i.ready) {\n    i.ready = true\n    i.status = constant.swing\n    instance.updateWidth(engine.getVariable(constant.blockWidth))\n    instance.updateHeight(engine.getVariable(constant.blockHeight))\n    instance.x = engine.width / 2\n    instance.y = ropeHeight * -1.5\n  }\n  const line = engine.getInstance('line')\n  switch (i.status) {\n    case constant.swing:\n      engine.getTimeMovement(\n        constant.hookDownMovement,\n        [[instance.y, instance.y + ropeHeight]],\n        (value) => {\n          instance.y = value\n        },\n        {\n          name: 'block'\n        }\n      )\n      swing(instance, engine, time)\n      break\n    case constant.beforeDrop:\n      i.x = instance.weightX - instance.calWidth\n      i.y = instance.weightY + (0.3 * instance.height) // add rope height\n      i.rotate = 0\n      i.ay = engine.pixelsPerFrame(0.0003 * engine.height) // acceleration of gravity\n      i.startDropTime = time\n      i.status = constant.drop\n      break\n    case constant.drop:\n      const deltaTime = time - i.startDropTime\n      i.startDropTime = time\n      i.vy += i.ay * deltaTime\n      i.y += (i.vy * deltaTime) + (0.5 * i.ay * (deltaTime ** 2))\n      const collision = checkCollision(instance, line)\n      const blockY = line.y - instance.height\n      const calRotate = (ins) => {\n        ins.originOutwardAngle = Math.atan(ins.height / ins.outwardOffset)\n        ins.originHypotenuse = Math.sqrt((ins.height ** 2)\n          + (ins.outwardOffset ** 2))\n        engine.playAudio('rotate')\n      }\n      switch (collision) {\n        case 1:\n          checkBlockOut(instance, engine)\n          break\n        case 2:\n          i.status = constant.rotateLeft\n          instance.y = blockY\n          instance.outwardOffset = (line.x + instance.calWidth) - instance.x\n          calRotate(instance)\n          break\n        case 3:\n          i.status = constant.rotateRight\n          instance.y = blockY\n          instance.outwardOffset = (line.collisionX + instance.calWidth) - instance.x\n          calRotate(instance)\n          break\n        case 4:\n        case 5:\n          i.status = constant.land\n          const lastSuccessCount = engine.getVariable(constant.successCount)\n          addSuccessCount(engine)\n          engine.setTimeMovement(constant.moveDownMovement, 500)\n          if (lastSuccessCount === 10 || lastSuccessCount === 15) {\n            engine.setTimeMovement(constant.lightningMovement, 150)\n          }\n          instance.y = blockY\n          line.y = blockY\n          line.x = i.x - i.calWidth\n          line.collisionX = line.x + i.width\n          // 作弊检测 超出左边或右边1／3\n          const cheatWidth = i.width * 0.3\n          if (i.x > engine.width - (cheatWidth * 2)\n            || i.x < -cheatWidth) {\n            engine.setVariable(constant.hardMode, true)\n          }\n          if (collision === 5) {\n            instance.perfect = true\n            addScore(engine, true)\n            engine.playAudio('drop-perfect')\n          } else {\n            addScore(engine)\n            engine.playAudio('drop')\n          }\n          break\n        default:\n          break\n      }\n      break\n    case constant.land:\n      engine.getTimeMovement(\n        constant.moveDownMovement,\n        [[instance.y, instance.y + (getMoveDownValue(engine, { pixelsPerFrame: s => s / 2 }))]],\n        (value) => {\n          if (!instance.visible) return\n          instance.y = value\n          if (instance.y > engine.height) {\n            instance.visible = false\n          }\n        },\n        {\n          name: instance.name\n        }\n      )\n      instance.x += getLandBlockVelocity(engine, time)\n      break\n    case constant.rotateLeft:\n    case constant.rotateRight:\n      const isRight = i.status === constant.rotateRight\n      const rotateSpeed = engine.pixelsPerFrame(Math.PI * 4)\n      const isShouldFall = isRight ? instance.rotate > 1.3 : instance.rotate < -1.3// 75度\n      const leftFix = isRight ? 1 : -1\n      if (isShouldFall) {\n        instance.rotate += (rotateSpeed / 8) * leftFix\n        instance.y += engine.pixelsPerFrame(engine.height * 0.7)\n        instance.x += engine.pixelsPerFrame(engine.width * 0.3) * leftFix\n      } else {\n        let rotateRatio = (instance.calWidth - instance.outwardOffset)\n          / instance.calWidth\n        rotateRatio = rotateRatio > 0.5 ? rotateRatio : 0.5\n        instance.rotate += rotateSpeed * rotateRatio * leftFix\n        const angle = instance.originOutwardAngle + instance.rotate\n        const rotateAxisX = isRight ? line.collisionX + instance.calWidth\n          : line.x + instance.calWidth\n        const rotateAxisY = line.y\n        instance.x = rotateAxisX -\n          (Math.cos(angle) * instance.originHypotenuse)\n        instance.y = rotateAxisY -\n          (Math.sin(angle) * instance.originHypotenuse)\n      }\n      checkBlockOut(instance, engine)\n      break\n    default:\n      break\n  }\n}\n\nconst drawSwingBlock = (instance, engine) => {\n  const bl = engine.getImg('blockRope')\n  engine.ctx.drawImage(\n    bl, instance.weightX - instance.calWidth\n    , instance.weightY\n    , instance.width, instance.height * 1.3\n  )\n  const leftX = instance.weightX - instance.calWidth\n  engine.debugLineY(leftX)\n}\n\nconst drawBlock = (instance, engine) => {\n  const { perfect } = instance\n  const bl = engine.getImg(perfect ? 'block-perfect' : 'block')\n  engine.ctx.drawImage(bl, instance.x, instance.y, instance.width, instance.height)\n}\n\nconst drawRotatedBlock = (instance, engine) => {\n  const { ctx } = engine\n  ctx.save()\n  ctx.translate(instance.x, instance.y)\n  ctx.rotate(instance.rotate)\n  ctx.translate(-instance.x, -instance.y)\n  drawBlock(instance, engine)\n  ctx.restore()\n}\n\nexport const blockPainter = (instance, engine) => {\n  const { status } = instance\n  switch (status) {\n    case constant.swing:\n      drawSwingBlock(instance, engine)\n      break\n    case constant.drop:\n    case constant.land:\n      drawBlock(instance, engine)\n      break\n    case constant.rotateLeft:\n    case constant.rotateRight:\n      drawRotatedBlock(instance, engine)\n      break\n    default:\n      break\n  }\n}\n","import { checkMoveDown, getMoveDownValue } from './utils'\nimport * as constant from './constant'\n\nconst randomCloudImg = (instance) => {\n  const { count } = instance\n  const clouds = ['c1', 'c2', 'c3']\n  const stones = ['c4', 'c5', 'c6', 'c7', 'c8']\n  const randomImg = array => (array[Math.floor(Math.random() * array.length)])\n  instance.imgName = count > 6 ? randomImg(stones) : randomImg(clouds)\n}\n\nexport const cloudAction = (instance, engine) => {\n  if (!instance.ready) {\n    instance.ready = true\n    randomCloudImg(instance)\n    instance.width = engine.getVariable(constant.cloudSize)\n    instance.height = engine.getVariable(constant.cloudSize)\n    const engineW = engine.width\n    const engineH = engine.height\n    const positionArr = [\n      { x: engineW * 0.1, y: -engineH * 0.66 },\n      { x: engineW * 0.65, y: -engineH * 0.33 },\n      { x: engineW * 0.1, y: 0 },\n      { x: engineW * 0.65, y: engineH * 0.33 }\n    ]\n    const position = positionArr[instance.index - 1]\n    instance.x = engine.utils.random(position.x, (position.x * 1.2))\n    instance.originX = instance.x\n    instance.ax = engine.pixelsPerFrame(instance.width * engine.utils.random(0.05, 0.08)\n      * engine.utils.randomPositiveNegative())\n    instance.y = engine.utils.random(position.y, (position.y * 1.2))\n  }\n  instance.x += instance.ax\n  if (instance.x >= instance.originX + instance.width\n    || instance.x <= instance.originX - instance.width) {\n    instance.ax *= -1\n  }\n  if (checkMoveDown(engine)) {\n    instance.y += getMoveDownValue(engine) * 1.2\n  }\n  if (instance.y >= engine.height) {\n    instance.y = -engine.height * 0.66\n    instance.count += 4\n    randomCloudImg(instance)\n  }\n}\n\nexport const cloudPainter = (instance, engine) => {\n  const { ctx } = engine\n  const cloud = engine.getImg(instance.imgName)\n  ctx.drawImage(cloud, instance.x, instance.y, instance.width, instance.height)\n}\n\n","export const gameStartNow = 'GAME_START_NOW'\nexport const gameUserOption = 'GAME_USER_OPTION'\nexport const hardMode = 'HARD_MODE'\n\nexport const successCount = 'SUCCESS_COUNT'\nexport const failedCount = 'FAILED_COUNT'\nexport const perfectCount = 'PERFECT_COUNT'\nexport const gameScore = 'GAME_SCORE'\n\nexport const hookDown = 'HOOK_DOWN'\nexport const hookUp = 'HOOK_UP'\nexport const hookNormal = 'HOOK_NORMAL'\n\nexport const bgImgOffset = 'BACKGROUND_IMG_OFFSET_HEIGHT'\nexport const lineInitialOffset = 'LINE_INITIAL_OFFSET'\nexport const bgLinearGradientOffset = 'BACKGROUND_LINEAR_GRADIENT_OFFSET_HEIGHT'\n\n\nexport const blockCount = 'BLOCK_COUNT'\nexport const blockWidth = 'BLOCK_WIDTH'\nexport const blockHeight = 'BLOCK_HEIGHT'\nexport const cloudSize = 'CLOUD_SIZE'\nexport const ropeHeight = 'ROPE_HEIGHT'\nexport const flightCount = 'FLIGHT_COUNT'\nexport const flightLayer = 'FLIGHT_LAYER'\n\nexport const rotateRight = 'ROTATE_RIGHT'\nexport const rotateLeft = 'ROTATE_LEFT'\nexport const swing = 'SWING'\nexport const beforeDrop = 'BEFORE_DROP'\nexport const drop = 'DROP'\nexport const land = 'LAND'\nexport const out = 'OUT'\n\nexport const initialAngle = 'INITIAL_ANGLE'\n\nexport const bgInitMovement = 'BG_INIT_MOVEMENT'\nexport const hookDownMovement = 'HOOK_DOWN_MOVEMENT'\nexport const hookUpMovement = 'HOOK_UP_MOVEMENT'\nexport const lightningMovement = 'LIGHTNING_MOVEMENT'\nexport const tutorialMovement = 'TUTORIAL_MOVEMENT'\nexport const moveDownMovement = 'MOVE_DOWN_MOVEMENT'\n","import { Instance } from 'cooljs'\nimport * as constant from './constant'\n\nconst getActionConfig = (engine, type) => {\n  const {\n    width, height, utils\n  } = engine\n  const { random } = utils\n  const size = engine.getVariable(constant.cloudSize)\n  const actionTypes = {\n    bottomToTop: {\n      x: width * random(0.3, 0.7),\n      y: height,\n      vx: 0,\n      vy: engine.pixelsPerFrame(height) * 0.7 * -1\n    },\n    leftToRight: {\n      x: size * -1,\n      y: height * random(0.3, 0.6),\n      vx: engine.pixelsPerFrame(width) * 0.4,\n      vy: engine.pixelsPerFrame(height) * 0.1 * -1\n    },\n    rightToLeft: {\n      x: width,\n      y: height * random(0.2, 0.5),\n      vx: engine.pixelsPerFrame(width) * 0.4 * -1,\n      vy: engine.pixelsPerFrame(height) * 0.1\n    },\n    rightTopToLeft: {\n      x: width,\n      y: 0,\n      vx: engine.pixelsPerFrame(width) * 0.6 * -1,\n      vy: engine.pixelsPerFrame(height) * 0.5\n    }\n  }\n  return actionTypes[type]\n}\n\n\nexport const flightAction = (instance, engine) => {\n  const { visible, ready, type } = instance\n  if (!visible) return\n  const size = engine.getVariable(constant.cloudSize)\n  if (!ready) {\n    const action = getActionConfig(engine, type)\n    instance.ready = true\n    instance.width = size\n    instance.height = size\n    instance.x = action.x\n    instance.y = action.y\n    instance.vx = action.vx\n    instance.vy = action.vy\n  }\n  instance.x += instance.vx\n  instance.y += instance.vy\n  if (instance.y + size < 0\n    || instance.y > engine.height\n    || instance.x + size < 0\n    || instance.x > engine.width) {\n    instance.visible = false\n  }\n}\n\nexport const flightPainter = (instance, engine) => {\n  const { ctx } = engine\n  const flight = engine.getImg(instance.imgName)\n  ctx.drawImage(flight, instance.x, instance.y, instance.width, instance.height)\n}\n\nexport const addFlight = (engine, number, type) => {\n  const flightCount = engine.getVariable(constant.flightCount)\n  if (flightCount === number) return\n  const flight = new Instance({\n    name: `flight_${number}`,\n    action: flightAction,\n    painter: flightPainter\n  })\n  flight.imgName = `f${number}`\n  flight.type = type\n  engine.addInstance(flight, constant.flightLayer)\n  engine.setVariable(constant.flightCount, number)\n}\n","import { getSwingBlockVelocity } from './utils'\nimport * as constant from './constant'\n\nexport const hookAction = (instance, engine, time) => {\n  const ropeHeight = engine.getVariable(constant.ropeHeight)\n  if (!instance.ready) {\n    instance.x = engine.width / 2\n    instance.y = ropeHeight * -1.5\n    instance.ready = true\n  }\n  engine.getTimeMovement(\n    constant.hookUpMovement,\n    [[instance.y, instance.y - ropeHeight]],\n    (value) => {\n      instance.y = value\n    },\n    {\n      after: () => {\n        instance.y = ropeHeight * -1.5\n      }\n    }\n  )\n  engine.getTimeMovement(\n    constant.hookDownMovement,\n    [[instance.y, instance.y + ropeHeight]],\n    (value) => {\n      instance.y = value\n    },\n    {\n      name: 'hook'\n    }\n  )\n  const initialAngle = engine.getVariable(constant.initialAngle)\n  instance.angle = initialAngle *\n    getSwingBlockVelocity(engine, time)\n  instance.weightX = instance.x +\n    (Math.sin(instance.angle) * ropeHeight)\n  instance.weightY = instance.y +\n    (Math.cos(instance.angle) * ropeHeight)\n}\n\nexport const hookPainter = (instance, engine) => {\n  const { ctx } = engine\n  const ropeHeight = engine.getVariable(constant.ropeHeight)\n  const ropeWidth = ropeHeight * 0.1\n  const hook = engine.getImg('hook')\n  ctx.save()\n  ctx.translate(instance.x, instance.y)\n  ctx.rotate((Math.PI * 2) - instance.angle)\n  ctx.translate(-instance.x, -instance.y)\n  engine.ctx.drawImage(hook, instance.x - (ropeWidth / 2), instance.y, ropeWidth, ropeHeight + 5)\n  ctx.restore()\n}\n\n","import { getMoveDownValue, getLandBlockVelocity } from './utils'\nimport * as constant from './constant'\n\nexport const lineAction = (instance, engine, time) => {\n  const i = instance\n  if (!i.ready) {\n    i.y = engine.getVariable(constant.lineInitialOffset)\n    i.ready = true\n    i.collisionX = engine.width - engine.getVariable(constant.blockWidth)\n  }\n  engine.getTimeMovement(\n    constant.moveDownMovement,\n    [[instance.y, instance.y + (getMoveDownValue(engine, { pixelsPerFrame: s => s / 2 }))]],\n    (value) => {\n      instance.y = value\n    },\n    {\n      name: 'line'\n    }\n  )\n  const landBlockVelocity = getLandBlockVelocity(engine, time)\n  instance.x += landBlockVelocity\n  instance.collisionX += landBlockVelocity\n}\n\nexport const linePainter = (instance, engine) => {\n  const { ctx, debug } = engine\n  if (!debug) {\n    return\n  }\n  ctx.save()\n  ctx.beginPath()\n  ctx.strokeStyle = 'red'\n  ctx.moveTo(instance.x, instance.y)\n  ctx.lineTo(instance.collisionX, instance.y)\n  ctx.lineWidth = 1\n  ctx.stroke()\n  ctx.restore()\n}\n\n","import { getHookStatus } from './utils'\nimport * as constant from './constant'\n\nexport const tutorialAction = (instance, engine, time) => {\n  const { width, height } = engine\n  const { name } = instance\n  if (!instance.ready) {\n    instance.ready = true\n    const tutorialWidth = width * 0.2\n    instance.updateWidth(tutorialWidth)\n    instance.height = tutorialWidth * 0.46\n    instance.x = engine.calWidth - instance.calWidth\n    instance.y = height * 0.45\n    if (name !== 'tutorial') {\n      instance.y += instance.height * 1.2\n    }\n  }\n  if (name !== 'tutorial') {\n    instance.y += Math.cos(time / 200) * instance.height * 0.01\n  }\n}\n\nexport const tutorialPainter = (instance, engine) => {\n  if (engine.checkTimeMovement(constant.tutorialMovement)) {\n    return\n  }\n  if (getHookStatus(engine) !== constant.hookNormal) {\n    return\n  }\n  const { ctx } = engine\n  const { name } = instance\n  const t = engine.getImg(name)\n  ctx.drawImage(t, instance.x, instance.y, instance.width, instance.height)\n}\n\n","import * as constant from './constant'\n\nexport const checkMoveDown = engine =>\n  (engine.checkTimeMovement(constant.moveDownMovement))\n\nexport const getMoveDownValue = (engine, store) => {\n  const pixelsPerFrame = store ? store.pixelsPerFrame : engine.pixelsPerFrame.bind(engine)\n  const successCount = engine.getVariable(constant.successCount)\n  const calHeight = engine.getVariable(constant.blockHeight) * 2\n  if (successCount <= 4) {\n    return pixelsPerFrame(calHeight * 1.25)\n  }\n  return pixelsPerFrame(calHeight)\n}\n\nexport const getAngleBase = (engine) => {\n  const successCount = engine.getVariable(constant.successCount)\n  const gameScore = engine.getVariable(constant.gameScore)\n  const { hookAngle } = engine.getVariable(constant.gameUserOption)\n  if (hookAngle) {\n    return hookAngle(successCount, gameScore)\n  }\n  if (engine.getVariable(constant.hardMode)) {\n    return 90\n  }\n  switch (true) {\n    case successCount < 10:\n      return 30\n    case successCount < 20:\n      return 60\n    default:\n      return 80\n  }\n}\n\nexport const getSwingBlockVelocity = (engine, time) => {\n  const successCount = engine.getVariable(constant.successCount)\n  const gameScore = engine.getVariable(constant.gameScore)\n  const { hookSpeed } = engine.getVariable(constant.gameUserOption)\n  if (hookSpeed) {\n    return hookSpeed(successCount, gameScore)\n  }\n  let hard\n  switch (true) {\n    case successCount < 1:\n      hard = 0\n      break\n    case successCount < 10:\n      hard = 1\n      break\n    case successCount < 20:\n      hard = 0.8\n      break\n    case successCount < 30:\n      hard = 0.7\n      break\n    default:\n      hard = 0.74\n      break\n  }\n  if (engine.getVariable(constant.hardMode)) {\n    hard = 1.1\n  }\n  return Math.sin(time / (200 / hard))\n}\n\nexport const getLandBlockVelocity = (engine, time) => {\n  const successCount = engine.getVariable(constant.successCount)\n  const gameScore = engine.getVariable(constant.gameScore)\n  const { landBlockSpeed } = engine.getVariable(constant.gameUserOption)\n  if (landBlockSpeed) {\n    return landBlockSpeed(successCount, gameScore)\n  }\n  const { width } = engine\n  let hard\n  switch (true) {\n    case successCount < 5:\n      hard = 0\n      break\n    case successCount < 13:\n      hard = 0.001\n      break\n    case successCount < 23:\n      hard = 0.002\n      break\n    default:\n      hard = 0.003\n      break\n  }\n  return Math.cos(time / 200) * hard * width\n}\n\nexport const getHookStatus = (engine) => {\n  if (engine.checkTimeMovement(constant.hookDownMovement)) {\n    return constant.hookDown\n  }\n  if (engine.checkTimeMovement(constant.hookUpMovement)) {\n    return constant.hookUp\n  }\n  return constant.hookNormal\n}\n\nexport const touchEventHandler = (engine) => {\n  if (!engine.getVariable(constant.gameStartNow)) return\n  if (engine.debug && engine.paused) {\n    return\n  }\n  if (getHookStatus(engine) !== constant.hookNormal) {\n    return\n  }\n  engine.removeInstance('tutorial')\n  engine.removeInstance('tutorial-arrow')\n  const b = engine.getInstance(`block_${engine.getVariable(constant.blockCount)}`)\n  if (b && b.status === constant.swing) {\n    engine.setTimeMovement(constant.hookUpMovement, 500)\n    b.status = constant.beforeDrop\n  }\n}\n\nexport const addSuccessCount = (engine) => {\n  const { setGameSuccess } = engine.getVariable(constant.gameUserOption)\n  const lastSuccessCount = engine.getVariable(constant.successCount)\n  const success = lastSuccessCount + 1\n  engine.setVariable(constant.successCount, success)\n  if (engine.getVariable(constant.hardMode)) {\n    engine.setVariable(constant.ropeHeight, engine.height * engine.utils.random(0.35, 0.55))\n  }\n  if (setGameSuccess) setGameSuccess(success)\n}\n\nexport const addFailedCount = (engine) => {\n  const { setGameFailed } = engine.getVariable(constant.gameUserOption)\n  const lastFailedCount = engine.getVariable(constant.failedCount)\n  const failed = lastFailedCount + 1\n  engine.setVariable(constant.failedCount, failed)\n  engine.setVariable(constant.perfectCount, 0)\n  if (setGameFailed) setGameFailed(failed)\n  if (failed >= 3) {\n    engine.pauseAudio('bgm')\n    engine.playAudio('game-over')\n    engine.setVariable(constant.gameStartNow, false)\n  }\n}\n\nexport const addScore = (engine, isPerfect) => {\n  const { setGameScore, successScore, perfectScore } = engine.getVariable(constant.gameUserOption)\n  const lastPerfectCount = engine.getVariable(constant.perfectCount, 0)\n  const lastGameScore = engine.getVariable(constant.gameScore)\n  const perfect = isPerfect ? lastPerfectCount + 1 : 0\n  const score = lastGameScore + (successScore || 25) + ((perfectScore || 25) * perfect)\n  engine.setVariable(constant.gameScore, score)\n  engine.setVariable(constant.perfectCount, perfect)\n  if (setGameScore) setGameScore(score)\n}\n\nexport const drawYellowString = (engine, option) => {\n  const {\n    string, size, x, y, textAlign\n  } = option\n  const { ctx } = engine\n  const fontName = 'wenxue'\n  const fontSize = size\n  const lineSize = fontSize * 0.1\n  ctx.save()\n  ctx.beginPath()\n  const gradient = ctx.createLinearGradient(0, 0, 0, y)\n  gradient.addColorStop(0, '#FAD961')\n  gradient.addColorStop(1, '#F76B1C')\n  ctx.fillStyle = gradient\n  ctx.lineWidth = lineSize\n  ctx.strokeStyle = '#FFF'\n  ctx.textAlign = textAlign || 'center'\n  ctx.font = `${fontSize}px ${fontName}`\n  ctx.strokeText(string, x, y)\n  ctx.fillText(string, x, y)\n  ctx.restore()\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Engine, Instance } from 'cooljs';\nimport { touchEventHandler } from './utils';\nimport { background } from './background';\nimport { lineAction, linePainter } from './line';\nimport { cloudAction, cloudPainter } from './cloud';\nimport { hookAction, hookPainter } from './hook';\nimport { tutorialAction, tutorialPainter } from './tutorial';\nimport * as constant from './constant';\nimport { startAnimate, endAnimate } from './animateFuncs';\n\nwindow.TowerGame = (option = {}) => {\n  const { width, height, canvasId, soundOn } = option;\n  const game = new Engine({\n    canvasId,\n    highResolution: true,\n    width,\n    height,\n    soundOn,\n    debug: true,\n  });\n  const pathGenerator = path => `./assets/${path}`;\n\n  game.addImg('background', pathGenerator('background.png'));\n  game.addImg('hook', pathGenerator('hook.png'));\n  game.addImg('blockRope', pathGenerator('block-rope.png'));\n  game.addImg('block', pathGenerator('block.png'));\n  game.addImg('block-perfect', pathGenerator('block-perfect.png'));\n  for (let i = 1; i <= 8; i += 1) {\n    game.addImg(`c${i}`, pathGenerator(`c${i}.png`));\n  }\n  game.addLayer(constant.flightLayer);\n  for (let i = 1; i <= 7; i += 1) {\n    game.addImg(`f${i}`, pathGenerator(`f${i}.png`));\n  }\n  game.swapLayer(0, 1);\n  game.addImg('tutorial', pathGenerator('tutorial.png'));\n  game.addImg('tutorial-arrow', pathGenerator('tutorial-arrow.png'));\n  game.addImg('heart', pathGenerator('heart.png'));\n  game.addImg('score', pathGenerator('score.png'));\n  game.addAudio('drop-perfect', pathGenerator('drop-perfect.mp3'));\n  game.addAudio('drop', pathGenerator('drop.mp3'));\n  game.addAudio('game-over', pathGenerator('game-over.mp3'));\n  game.addAudio('rotate', pathGenerator('rotate.mp3'));\n  game.addAudio('bgm', pathGenerator('bgm.mp3'));\n  game.setVariable(constant.blockWidth, game.width * 0.25);\n  game.setVariable(constant.blockHeight, game.getVariable(constant.blockWidth) * 0.71);\n  game.setVariable(constant.cloudSize, game.width * 0.3);\n  game.setVariable(constant.ropeHeight, game.height * 0.4);\n  game.setVariable(constant.blockCount, 0);\n  game.setVariable(constant.successCount, 0);\n  game.setVariable(constant.failedCount, 0);\n  game.setVariable(constant.gameScore, 0);\n  game.setVariable(constant.hardMode, false);\n  game.setVariable(constant.gameUserOption, option);\n  for (let i = 1; i <= 4; i += 1) {\n    const cloud = new Instance({\n      name: `cloud_${i}`,\n      action: cloudAction,\n      painter: cloudPainter,\n    });\n    cloud.index = i;\n    cloud.count = 5 - i;\n    game.addInstance(cloud);\n  }\n  const line = new Instance({\n    name: 'line',\n    action: lineAction,\n    painter: linePainter,\n  });\n  game.addInstance(line);\n  const hook = new Instance({\n    name: 'hook',\n    action: hookAction,\n    painter: hookPainter,\n  });\n  game.addInstance(hook);\n\n  game.startAnimate = startAnimate;\n  game.endAnimate = endAnimate;\n  game.paintUnderInstance = background;\n  game.addKeyDownListener('enter', () => {\n    if (game.debug) game.togglePaused();\n  });\n  game.touchStartListener = () => {\n    touchEventHandler(game);\n  };\n\n  game.playBgm = () => {\n    game.playAudio('bgm', true);\n  };\n\n  game.pauseBgm = () => {\n    game.pauseAudio('bgm');\n  };\n\n  game.start = () => {\n    const tutorial = new Instance({\n      name: 'tutorial',\n      action: tutorialAction,\n      painter: tutorialPainter,\n    });\n    game.addInstance(tutorial);\n    const tutorialArrow = new Instance({\n      name: 'tutorial-arrow',\n      action: tutorialAction,\n      painter: tutorialPainter,\n    });\n    game.addInstance(tutorialArrow);\n    game.setTimeMovement(constant.bgInitMovement, 500);\n    game.setTimeMovement(constant.tutorialMovement, 500);\n    game.setVariable(constant.gameStartNow, true);\n  };\n\n  return game;\n};\n"],"sourceRoot":""}